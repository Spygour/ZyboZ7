/*  adcsonar.c - The simplest kernel module.

* Copyright (C) 2013-2022 Xilinx, Inc
* Copyright (c) 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include "xadc.h"
#include <linux/atomic.h>
#include <linux/delay.h>
#include <linux/device.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/platform_device.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/cdev.h>
#include <linux/kdev_t.h>



/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Xilinx Inc.");
MODULE_DESCRIPTION("adcsonar - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "adcsonar"
typedef enum
{
    XADC_START_CONV,
    XADC_CHECK_STATUS,
    XADC_CONV_END
} XADC_KSTATE;

typedef struct
{
    uint32_t distance;
    uint32_t version;
} ADCSONAR_DATA;
/* Address is 0xf8007100 */
/* adc: adc@f8007100 {
    compatible = "xlnx,zynq-xadc-1.00.a";
    reg = <0xf8007100 0x20>;
    interrupts = <0 7 4>;
    interrupt-parent = <&intc>;
    clocks = <&clkc 12>;
}; */

/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
/* Variables */
unsigned myint = 0xdeadbeef;
char* mystr = "default";
static atomic_t xadc_irq_flag = ATOMIC_INIT(0);
static const char* xadc_dev_string = "xlnx,zynq-xadc-1.00.a";
static XADC_KSTATE adcSonar_State = XADC_START_CONV;
static uint16_t adcSonar_RawData;

/* Data to send to userspace */
static ADCSONAR_DATA adcSonar_Data;
/* Spinlock to avoid race conditions */
static DEFINE_SPINLOCK(data_lock);

static uint32_t adcSonar_Status;

static XADC_CONFIG_T xadc_Kconfig;
static struct task_struct* xadc_ktask;

/* This are used to store the kernel module to a path */
static struct class* adcsonar_class;
static struct device* adcsonar_device;
static int adcsonar_major = 0;
/* Fops which is used to read and send data to userspace */
static ssize_t adcSonar_read(struct file* file, char __user* buf, size_t count, loff_t* ppos);

static const struct file_operations fops = {
    .read = adcSonar_read,
};

/* Functions */

static void Xadc_IrqCb(void) { atomic_set(&xadc_irq_flag, 1); }

static void adcSonar_ParamsInit(void)
{

    adcSonar_Data.distance = 0u;
    adcSonar_Data.version = 0u;
    /* Enable interrupt and sequence mode */
    xadc_Kconfig.intr_en = true;
    xadc_Kconfig.seq_channel_mask = (1U << 14U) | (1U << 7U); /* AUX 14 AND AUX 7 */
    xadc_Kconfig.seq_mode_en = true;

    /* Config 1 register */
    xadc_Kconfig.config1.B.averaging_sample = XADC_AVERAGING_16_SAMPLES;
    xadc_Kconfig.config1.B.bibolar_en = 1U;
    xadc_Kconfig.config1.B.channel = XADC_CHANNEL_VAUX14;
    xadc_Kconfig.config1.B.disable_average = 0u;
    xadc_Kconfig.config1.B.event_mode_en = 0U; /* Continuous it does not work the event for now */

    /* Config 2 register */
    xadc_Kconfig.config2.B.overtemp_alm_dis = 1U;
    xadc_Kconfig.config2.B.alarm_ext_dis = 0U;
    xadc_Kconfig.config2.B.alarm_int_dis = 0U;
    xadc_Kconfig.config2.B.calib_en = XADC_SENSOR_OFFSET_CORR_EN | XADC_SENSOR_OFFSET_GAIN_CORR_EN;
    xadc_Kconfig.config2.B.channel_seq_mode = XADC_SINGLE_PASS_SEQ_MODE;

    /* Config 3 register */
    xadc_Kconfig.config3.B.power_down_en = 0u;
    xadc_Kconfig.config3.B.drp_clk_pre = XADC_DCLCK_DIV_4;
    /* Axi size */
    xadc_Kconfig.axi_size = 0x10000;

    /* Base address */
    xadc_Kconfig.xadc_base_address = 0x43C10000U;

    /* Interrupt */
    xadc_Kconfig.irq_handler = NULL;

    /* Device string */
    xadc_Kconfig.device_string = xadc_dev_string;
}

static ssize_t adcSonar_read(struct file* file, char __user* buf, size_t count, loff_t* ppos)
{
    ADCSONAR_DATA tmp_data;

    spin_lock(&data_lock);
    tmp_data.distance = adcSonar_Data.distance;
    tmp_data.version = adcSonar_Data.version;
    spin_unlock(&data_lock);

    if (copy_to_user(buf, &tmp_data, sizeof(tmp_data)))
    {
        return -EFAULT;
    }
    return sizeof(tmp_data);
}

static int adcSonar_thread(void* data)
{
    while (!kthread_should_stop())
    {
        switch (adcSonar_State)
        {
        case XADC_START_CONV:
            adcSonar_State = XADC_CHECK_STATUS;
            break;

        case XADC_CHECK_STATUS:
            /* First we read the status to avoid failure of the sequence */
            if (Xadc_GetSeqStatusAndClear())
            {
                /* Start from here */
                adcSonar_RawData = ioread16(Xadc_Base + XADC_VAUX14_RES) >> 4;
                spin_lock(&data_lock);
                adcSonar_Data.distance = adcSonar_RawData;
                adcSonar_Data.version++;
                spin_unlock(&data_lock);
                Xadc_RestartSequence();
            }
            /* Otherwise go to first step */
            else if (Xadc_GetSeqFlagAndClear())
            {
                adcSonar_RawData = ioread16(Xadc_Base + XADC_VAUX14_RES) >> 4;
                spin_lock(&data_lock);
                adcSonar_Data.distance = adcSonar_RawData;
                adcSonar_Data.version++;
                spin_unlock(&data_lock);
                Xadc_RestartSequence();
            }
            adcSonar_State = XADC_CONV_END;
            break;
        case XADC_CONV_END:
        {
            if (Xadc_GetSeqFlagAndClear())
            {
                /* Handle the data that you took */
                adcSonar_RawData = ioread16(Xadc_Base + XADC_VAUX14_RES) >> 4;
                spin_lock(&data_lock);
                adcSonar_Data.distance = adcSonar_RawData;
                adcSonar_Data.version++;
                spin_unlock(&data_lock);
                Xadc_RestartSequence();
                adcSonar_State = XADC_CONV_END;
            }
        }
        break;

        default:
            break;
        }
        msleep(100);
    }
    return 0;
}

static int __init adcsonar_init(void)
{
    printk("<1>Hello Xadc module world.\n");
    printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint, mystr);

    adcsonar_major = register_chrdev(0, DRIVER_NAME, &fops);
    if (adcsonar_major < 0)
        return adcsonar_major;

    adcsonar_class = class_create("adc_class");
    if (IS_ERR(adcsonar_class))
        return PTR_ERR(adcsonar_class);

    adcsonar_device = device_create(adcsonar_class, NULL, MKDEV(adcsonar_major, 0), NULL, DRIVER_NAME);
    if (IS_ERR(adcsonar_device))
        return PTR_ERR(adcsonar_device);

    pr_info("adcsonar device created at /dev/%s\n", DRIVER_NAME);

    adcSonar_ParamsInit();

    Xadc_Init(&xadc_Kconfig);
    /* Avoid starting a thread if the initialization is failed */
    if (Xadc_Base != NULL)
    {
        xadc_ktask = kthread_run(adcSonar_thread, NULL, "adcSonar_thread");
    }

    return 0;
}

static void __exit adcsonar_exit(void)
{
    printk(KERN_ALERT "Goodbye module world.\n");
    if (xadc_ktask)
    {
        kthread_stop(xadc_ktask);
    }
    Xadc_DeInit();

    
    /* Destroy device and class */
    if (adcsonar_device)
        device_destroy(adcsonar_class, MKDEV(adcsonar_major, 0));

    if (adcsonar_class)
        class_destroy(adcsonar_class);

    /* Unregister char device */
    if (adcsonar_major > 0)
        unregister_chrdev(adcsonar_major, DRIVER_NAME);
}

module_init(adcsonar_init);
module_exit(adcsonar_exit);
