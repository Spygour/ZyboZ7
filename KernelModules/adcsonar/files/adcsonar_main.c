/*  adcsonar.c - The simplest kernel module.

* Copyright (C) 2013-2022 Xilinx, Inc
* Copyright (c) 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/atomic.h>
#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/platform_device.h>
#include "xadc.h"

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("adcsonar - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "adcsonar"
#define URM09_MAX_RESOLUTION 4095
#define URM09_MAX_DISTANCE 520

typedef enum 
{
	XADC_START_CONV,
	XADC_CONV_END
}XADC_KSTATE;
/* Address is 0xf8007100 */
/* adc: adc@f8007100 {
	compatible = "xlnx,zynq-xadc-1.00.a";
	reg = <0xf8007100 0x20>;
	interrupts = <0 7 4>;
	interrupt-parent = <&intc>;
	clocks = <&clkc 12>;
}; */

/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
/* Variables */
unsigned myint = 0xdeadbeef;
char *mystr = "default";
static atomic_t xadc_irq_flag = ATOMIC_INIT(0);
static const char *xadc_dev_string = "xlnx,zynq-xadc-1.00.a";
static XADC_KSTATE adcSonar_State = XADC_START_CONV;
static uint16_t adcSonar_RawData;
static float adcSonar_Distance;
static uint32_t adcSonar_Status;

static XADC_CONFIG_T xadc_Kconfig;
static struct task_struct *xadc_ktask;

/* Functions */

static void Xadc_IrqCb(void)
{
	atomic_set(&xadc_irq_flag, 1);
}

static void adcSonar_ParamsInit(void)
{
	/* Enable interrupt and sequence mode */
	xadc_Kconfig.intr_en = true;
	xadc_Kconfig.seq_channel_mask = (1U << 14U) | (1U << 7U); /* AUX 14 AND AUX 7 */
	xadc_Kconfig.seq_mode_en = true;

	/* Config 1 register */
	xadc_Kconfig.config1.B.averaging_sample = XADC_AVERAGING_16_SAMPLES;
	xadc_Kconfig.config1.B.bibolar_en = 1U;
	xadc_Kconfig.config1.B.channel = XADC_CHANNEL_VAUX14;
	xadc_Kconfig.config1.B.disable_average = 0u;
	xadc_Kconfig.config1.B.event_mode_en = 1U;

	/* Config 2 register */
	xadc_Kconfig.config2.B.overtemp_alm_dis = 1U;
	xadc_Kconfig.config2.B.alarm_ext_dis = 0U;
	xadc_Kconfig.config2.B.alarm_int_dis = 0U;
	xadc_Kconfig.config2.B.calib_en = XADC_SENSOR_OFFSET_CORR_EN | XADC_SENSOR_OFFSET_GAIN_CORR_EN;
	xadc_Kconfig.config2.B.channel_seq_mode = XADC_SINGLE_PASS_SEQ_MODE;

	/* Config 3 register */
	xadc_Kconfig.config3.B.power_down_en = 0u;
	xadc_Kconfig.config3.B.drp_clk_pre = XADC_DCLCK_DIV_4;
	/* Axi size */
	xadc_Kconfig.axi_size = 0x10000;

	/* Base address */
	xadc_Kconfig.xadc_base_address = 0x43C10000U;

	/* Interrupt */
	xadc_Kconfig.irq_handler = Xadc_IrqCb;

	/* Device string */
	xadc_Kconfig.device_string = xadc_dev_string;
}

static int adcSonar_thread(void *data)
{
	while (!kthread_should_stop())
	{
		switch (adcSonar_State)
		{
			case XADC_START_CONV:
			if (Xadc_StartConvertion())
			{
				adcSonar_State = XADC_CONV_END;
			}
			break;

			case XADC_CONV_END:
			{
				if (atomic_xchg(&xadc_irq_flag, 0) == 1u)
				{
					adcSonar_Status = ioread32(Xadc_Base + XADC_STATUS_OFFSET);
					/* Handle the data that you took */
					adcSonar_RawData = ioread16(Xadc_Base + XADC_VAUX14_RES) >> 4;
        			adcSonar_Distance = (float)(adcSonar_RawData) * URM09_MAX_DISTANCE/URM09_MAX_RESOLUTION;
					printk("Distance is %u\n", adcSonar_RawData);
					adcSonar_State = XADC_START_CONV;
				}
			}
			break;

			default:
			break;
		}
		msleep(1000);
	}
	return 0;
}


static int __init adcsonar_init(void)
{
	printk("<1>Hello Xadc module world.\n");
	printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,
	       mystr);

	adcSonar_ParamsInit();

	Xadc_Init(&xadc_Kconfig);
	/* Avoid starting a thread if the initialization is failed */
	if (Xadc_Base != NULL)
	{
		xadc_ktask = kthread_run(adcSonar_thread, NULL, "adcSonar_thread");
	}
	
	return 0;
}


static void __exit adcsonar_exit(void)
{
	printk(KERN_ALERT "Goodbye module world.\n");
	if (xadc_ktask)
	{
			kthread_stop(xadc_ktask);
	}
	Xadc_DeInit();

}

module_init(adcsonar_init);
module_exit(adcsonar_exit);
