/*  motorcontrol.c - The simplest kernel module.

* Copyright (C) 2013-2022 Xilinx, Inc
* Copyright (c) 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/delay.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/module.h>
#include <linux/pwm.h>
#include <linux/types.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Xilinx Inc.");
MODULE_DESCRIPTION("motorcontrol - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "motorcontrol"
#define PWM_PERIOD 50000
#define PWM_STEP 500
#define PWM_MAX 49500
#define PWM_MIN 500

static struct task_struct* ledControlTask;
static struct pwm_device* Pwm0;
static uint32_t dutycycle = 0;
static bool pwm_dir = true;
// static irqreturn_t motorcontrol_irq(int irq, void *lp)
//{
//}

static int ledControlThread(void* data)
{
    while (!kthread_should_stop())
    {
        /* Here you add the function */
        if (dutycycle > PWM_MAX)
        {
            pwm_dir = false;
        }
        else if (dutycycle < PWM_MIN)
        {
            pwm_dir = true;
        }
        if (pwm_dir)
        {
            dutycycle += PWM_STEP;
        }
        else
        {
            dutycycle -= PWM_STEP;
        }
        pwm_config(Pwm0, dutycycle, PWM_PERIOD);
        msleep(100);
    }
    return 0;
}

static int __init motorcontrol_init(void)
{

    printk("<1>Welcome to Pwm Init bro\n");
    /* Initialization of the pwm signals */
    Pwm0 = pwm_get(NULL, "pwm0");
    if (IS_ERR(Pwm0))
    {
        pr_err("Failed to get PWM\n");
        return PTR_ERR(Pwm0);
    }
    pwm_config(Pwm0, 25000, PWM_PERIOD);
    pwm_enable(Pwm0);

    ledControlTask = kthread_run(ledControlThread, NULL, "multiple_pwmthread");
    return 0;
}

static void __exit motorcontrol_exit(void)
{
    /* DeInitialization of the pwm signals */
    printk(KERN_ALERT "Goodbye module world.\n");
    kthread_stop(ledControlTask);

    pwm_disable(Pwm0);
    pwm_put(Pwm0);

    printk(KERN_INFO "Motor control module unloaded\n");
}

module_init(motorcontrol_init);
module_exit(motorcontrol_exit);
