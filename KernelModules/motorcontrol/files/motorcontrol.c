/*  motorcontrol.c - The simplest kernel module.

* Copyright (C) 2013-2022 Xilinx, Inc
* Copyright (c) 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/pwm.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/types.h>


/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("motorcontrol - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "motorcontrol"
#define PWM_PERIOD 50000
#define PWM_STEP 500
#define PWM_MAX 49500
#define PWM_MIN 500

static struct task_struct *ledControlTask;
static struct pwm_device* Pwm0;
static uint32_t dutycycle = 0;
static bool pwm_dir = true;
//static irqreturn_t motorcontrol_irq(int irq, void *lp)
//{
//}


static int ledControlThread(void *data)
{
	while (!kthread_should_stop()) 
	{
		/* Here you add the function */
		if (dutycycle > PWM_MAX)
		{
			pwm_dir = false;
		}
		else if (dutycycle < PWM_MIN)
		{
			pwm_dir = true;
		}
		if (pwm_dir)
		{
			dutycycle += PWM_STEP;
		}
		else
		{
			dutycycle -= PWM_STEP;
		}
		pwm_config(Pwm0, dutycycle, PWM_PERIOD);
		msleep(100);
  }
	return 0;
}


static int __init motorcontrol_init(void)
{

	printk("<1>Welcome to Pwm Init bro\n");
  	/* Initialization of the pwm signals */
  	Pwm0 = pwm_get(NULL, "pwm0");
  	if (IS_ERR(Pwm0)) 
	{
    	pr_err("Failed to get PWM\n");
    	return PTR_ERR(Pwm0);
  	}
  	pwm_config(Pwm0, 25000, PWM_PERIOD);
  	pwm_enable(Pwm0);

	ledControlTask = kthread_run(ledControlThread, NULL, "multiple_pwmthread");
	return 0;
}


static void __exit motorcontrol_exit(void)
{
	/* DeInitialization of the pwm signals */
	printk(KERN_ALERT "Goodbye module world.\n");
	kthread_stop(ledControlTask);

	pwm_disable(Pwm0);
	pwm_put(Pwm0);

	printk(KERN_INFO "Motor control module unloaded\n");
}

module_init(motorcontrol_init);
module_exit(motorcontrol_exit);
