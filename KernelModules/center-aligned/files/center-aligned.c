/*  center-aligned.c - The simplest kernel module.

* Copyright (C) 2013-2022 Xilinx, Inc
* Copyright (c) 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/kthread.h>
#include <linux/module.h>
#include <linux/irq.h>
#include <linux/io.h>
#include <linux/delay.h>
#include <linux/types.h>
#include <linux/interrupt.h>
#include <linux/of.h>     
#include <linux/of_irq.h> 

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("center-aligned - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "center-aligned"

/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
unsigned myint = 0xdeadbeef;
char *mystr = "default";

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);


#define CENTER_ALIGNED_AXI_BASE   0x43c00000
#define CENTER_ALIGNED_AXI_SIZE   0x10000

#define PERIOD 0
#define DUTY1 4
#define DUTY2 8
#define DUTY3 12
#define CTRL 16
#define DEADTIME 20
#define INTR 24

#define CENTER_ALLIGNED_INTERRUPT_ID 61

#define PWM_ENABLE 0
#define PWM_CENTER_ALIGNED 1
#define PWM_INTERRUPT_ENABLE 2
#define PWM_DEADTIME_ENABLE 3

typedef enum 
{
	FIRST_PHASE,
	SECOND_PHASE,
	DEFAULT
}PWM_STATE;

static PWM_STATE CenterAligned_State = FIRST_PHASE;

static uint32_t CenterAligned_CtrReg = 0; 

static void __iomem *CenterAligned_base;

static struct task_struct *CenterAligned_task;

static int CenterAligned_InterruptId;


/* Main Isr that can be used to update the values of the PWMS */
static irqreturn_t CenterAligned_Irq(int irq, void *lp)
{
	uint32_t status = ioread32(CenterAligned_base + INTR);
	switch(CenterAligned_State)
	{
		case FIRST_PHASE:
		{
			iowrite32(35000, CenterAligned_base + DUTY1);
			iowrite32(25000, CenterAligned_base + DUTY2);
			iowrite32(2000, CenterAligned_base + DUTY3);
			CenterAligned_State = SECOND_PHASE;
			break;
		}

		case SECOND_PHASE:
		{
			iowrite32(10000, CenterAligned_base + DUTY1);
			iowrite32(5000, CenterAligned_base + DUTY2);
			iowrite32(40000, CenterAligned_base + DUTY3);
			CenterAligned_State = FIRST_PHASE;
			pr_info("gia pame ligo\n");
			/* Deactivate the interrupt */
			break;
		}

		default:
		  pr_info("STILL THERE GAMW TO SYMPAN\n");
			CenterAligned_State = FIRST_PHASE;
			break;
	}
	/* Clear the interrupt flag , restart the interrupt */
	iowrite32((status | 1u) , CenterAligned_base + INTR);
	return IRQ_HANDLED;
}

static inline void axi_write32_safe(void __iomem *base, uint32_t offset, uint32_t val)
{
	iowrite32(val, base + offset);
	mb();
	udelay(1);
}

static int center_aligned_thread(void *data);

static bool Pwm_Init(void);

static inline int InterruptCheck(void)
{
	struct device_node *np;

	np = of_find_compatible_node(NULL, NULL, "xlnx,PwmCenterAligned-1.0"); /* Please modify this */
	if (!np) {
	    pr_err("PWM node not found in device tree\n");
	    return -ENODEV;
	}

	CenterAligned_InterruptId = irq_of_parse_and_map(np, 0);
	if (CenterAligned_InterruptId <= 0) {
	    pr_err("PWM interrupt not mapped\n");
	    of_node_put(np);
	    return -EINVAL;
	}

	pr_info("Mapped PWM IRQ = %d\n", CenterAligned_InterruptId);
	of_node_put(np);

	return 0;
}


static int __init CenterAligned_Init(void)
{
	printk("<1>Hello module world.\n");
	printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,
	       mystr);
	pr_info("AXI test module loaded\n");

  // Map AXI1
	int ret;

	ret = InterruptCheck();
	if (ret)
	{
		pr_err("Interrupt is not mapped in the component with code %d\n", ret);
		goto irq_failed;
	}

	ret = request_irq(CenterAligned_InterruptId, CenterAligned_Irq, 0, "my_center_alligned_isr", NULL);
	if (ret)
	{
		pr_err("Interrupt init failed with error code %d\n", ret);
		goto irq_failed;
	}
	
	bool flag = Pwm_Init();
	if (!flag) 
	{
        pr_err("Failed to write dutycycles mothefucka\n");
        goto  pwm_failed;
    }

	//CenterAligned_task = kthread_run(center_aligned_thread, NULL, "multiple_pwmthread");

	return 0;

	irq_failed:
	return ret;

	pwm_failed:
	return -ENOMEM;

}

static bool Pwm_Init(void)
{
	CenterAligned_base = ioremap(CENTER_ALIGNED_AXI_BASE, CENTER_ALIGNED_AXI_SIZE);
    if (!CenterAligned_base) 
	{
        pr_err("Failed to map AXI1\n");
        goto error;
    }

	axi_write32_safe(CenterAligned_base, PERIOD, 50000);
	axi_write32_safe(CenterAligned_base, DUTY1, 10000);
	axi_write32_safe(CenterAligned_base, DUTY2, 5000);
	axi_write32_safe(CenterAligned_base, DUTY3, 40000);
	/* Pwm starts here - control  = 1 | 2 | 4 */
	axi_write32_safe(CenterAligned_base, CTRL, (1 << PWM_ENABLE) | (1 << PWM_CENTER_ALIGNED) | (1 << PWM_INTERRUPT_ENABLE));

	CenterAligned_CtrReg = (uint32_t)ioread32(CenterAligned_base + CTRL);
	
	return true;

	error:
	return false;
}


/* This is a main task that can be used for different reasons */
static int center_aligned_thread(void *data)
{
	while (!kthread_should_stop()) 
	{
		axi_write32_safe(CenterAligned_base, DUTY1, 35000);
		axi_write32_safe(CenterAligned_base, DUTY2, 25000);
		axi_write32_safe(CenterAligned_base, DUTY3, 2000);
		msleep(100);
		axi_write32_safe(CenterAligned_base, DUTY1, 10000);
		axi_write32_safe(CenterAligned_base, DUTY2, 5000);
		axi_write32_safe(CenterAligned_base, DUTY3, 40000);
		msleep(100);
	}
	return 0;
}



static void __exit CenterAligned_Exit(void)
{
	free_irq(CenterAligned_InterruptId, NULL);
  //kthread_stop(CenterAligned_task);
	axi_write32_safe(CenterAligned_base, CTRL, 0x0);
	iounmap(CenterAligned_base);
	printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(CenterAligned_Init);
module_exit(CenterAligned_Exit);

