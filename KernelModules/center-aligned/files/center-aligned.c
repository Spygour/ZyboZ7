/*  center-aligned.c - The simplest kernel module.

* Copyright (C) 2013-2022 Xilinx, Inc
* Copyright (c) 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/kthread.h>
#include <linux/module.h>
#include <linux/irq.h>
#include <linux/io.h>
#include <linux/delay.h>
#include <linux/types.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("center-aligned - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "center-aligned"

/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
unsigned myint = 0xdeadbeef;
char *mystr = "default";

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);


#define CENTER_ALIGNED_AXI_BASE   0x43c00000
#define CENTER_ALIGNED_AXI_SIZE   0x10000

#define PERIOD 0
#define DUTY1 4
#define DUTY2 8
#define DUTY3 12
#define CTRL 16

static void __iomem *center_aligned_base;

static struct task_struct *center_aligned_task;



static irqreturn_t center_aligned_irq(int irq, void *lp)
{
	printk("center-aligned interrupt\n");
	return IRQ_HANDLED;
}

static inline void axi_write32_safe(void __iomem *base, uint32_t offset, uint32_t val)
{
	iowrite32(val, base + offset);
	mb();
	udelay(1);
}

static int center_aligned_thread(void *data);

static bool Pwm_Init(void);


static int __init center_aligned_init(void)
{
	printk("<1>Hello module world.\n");
	printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,
	       mystr);
	pr_info("AXI test module loaded\n");

    // Map AXI1

	bool flag = Pwm_Init();
	if (!flag) 
	{
        pr_err("Failed to write dutycycles mothefucka\n");
        return -ENOMEM;
    }

	center_aligned_task = kthread_run(center_aligned_thread, NULL, "multiple_pwmthread");

	return 0;
}

static bool Pwm_Init(void)
{
	center_aligned_base = ioremap(CENTER_ALIGNED_AXI_BASE, CENTER_ALIGNED_AXI_SIZE);
    if (!center_aligned_base) 
	{
        pr_err("Failed to map AXI1\n");
        goto error;
    }

	axi_write32_safe(center_aligned_base, PERIOD, 50000);
	axi_write32_safe(center_aligned_base, DUTY1, 10000);
	axi_write32_safe(center_aligned_base, DUTY2, 5000);
	axi_write32_safe(center_aligned_base, DUTY3, 40000);
	/* Pwm starts here - control  = 1 */
	axi_write32_safe(center_aligned_base, CTRL, 0x1);
	
	return true;

	error:
	return false;
}

static int center_aligned_thread(void *data)
{
	while (!kthread_should_stop()) 
	{
		axi_write32_safe(center_aligned_base, DUTY1, 35000);
		axi_write32_safe(center_aligned_base, DUTY2, 25000);
		axi_write32_safe(center_aligned_base, DUTY3, 2000);
		msleep(100);
		axi_write32_safe(center_aligned_base, DUTY1, 10000);
		axi_write32_safe(center_aligned_base, DUTY2, 5000);
		axi_write32_safe(center_aligned_base, DUTY3, 40000);
		msleep(100);
	}
	return 0;
}



static void __exit center_aligned_exit(void)
{
	kthread_stop(center_aligned_task);
	axi_write32_safe(center_aligned_base, CTRL, 0x0);
	iounmap(center_aligned_base);
	printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(center_aligned_init);
module_exit(center_aligned_exit);
